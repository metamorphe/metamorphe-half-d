<%= javascript_include_tag 'metamorphehalf/planebox', 'data-turbolinks-track' => true %>


<style type="text/css">
	html, body{
		height: 100% !important;
	}
</style>
<script type="text/javascript">
var tc, storage, alert, depthWorker, textureNames, textureMap;


$(function(){
	initWorkers();
	storage = new WebStorage();
	tc = new TactileController();
	textureNames = $.map(TactileController.textures, function(el, i){
			var path_tokens = el.split('/');
			return path_tokens[path_tokens.length - 1].split(".")[0];
		});
	textureMap = {};
	alert = new UIAlert(tc.env.container);
	configureGUI(tc);
	tc.init();
	
});

function workPackage(texture, geom){
	this.pixels = Filters.filterImage(Filters.grayscale, texture.image);
	this.faces = geom.faces;
	this.faceVertexUvs = geom.faceVertexUvs;
}

function initWorkers(){
	depthWorker = new Worker('/assets/metamorphehalf/ScanWorker.js');
}

function TactileController(){
	this.texture = GET().texture || "corn";
	this.engine = GET().engine || "shade";
	this.current_model;
	this.magnitude = 20.0;
	this.loaded = {};
	this.env = new WebEnv($("#ThreeJS"));
	this.preview;
}

TactileController.textures =  <%= @files %>;

TactileController.prototype = {
	init: function(){
		var self = this;
		this.load();
		this.preview = new ImagePreview(this.env.container, textureMap[this.texture]);
	},
	load:function(){
		console.log("Loading", this.texture, "on", this.engine);
		var self = this;

		var model = this.loaded[this.texture];
		if(typeof model === "undefined") model = new TactileModel(textureMap[this.texture], 
			70, 70, 2, 100, self.magnitude);
		model.load(this.engine, this.add, self);
	},
	add: function(tc, model){
		console.log("Added " + model.name);
		tc.clear();
		tc.current_model = model;
		tc.env.scene.add(tc.current_model[tc.engine].obj.mesh);
		tc.preview.swap(textureMap[tc.texture]);
		tc.mag();
		if(tc.engine == "bump")
			alert.hide();
		hist = generateURL();
		history.pushState({}, hist.title, hist.href);
	}, 
	switch: function(){
		console.log("Switching to", textureMap[this.texture]);
		var self = this;
		UIAlert.sync(function(){
			if(self.engine == "shade")
				alert.flash("Switching to: " + textureMap[self.texture], 1500);
			if(this.engine == "bump")
				alert.notice("Calculating " + self.texture +  " model ...");
			}, function(){
				self.load();
			});
	},
	mag: function(){
		this.current_model.mag(this.engine, this.magnitude);
	},
	clear: function(){
		console.log("Clearing the stage.");
		if(typeof this.current_model === "undefined") return; 
		if(typeof this.current_model.bump.obj !== "undefined")
			this.env.scene.remove(this.current_model.bump.obj.mesh);
		if(typeof this.current_model.shade.obj !== "undefined")
			this.env.scene.remove(this.current_model.shade.obj.mesh);
		console.log("Cleared the stage.");
	}, 
	save: function(){
		// TODO: trigger change with controller
		// this.engine = "bump";
		// tc.switch();
		var self = this;
		this.current_model.save(this.texture);
		alert.flash("Model saved!", 1000);
	}, 
	clear_cache: function(){
		storage.clear();
		alert.flash("Cleared cache", 1000);
	}, 
	clear_self: function(){
		storage.remove(this.current_model.name);
		alert.flash("Cleared self from cache", 1000);
	}
}


function TactileModel(texture, h, w, d, resolution, mag){
	this.name = texture;
	this.path = textureMap[texture];
	this.shade = new ShaderBumpBox(texture, mag, h, w, d, resolution);   
	this.bump = new LambertBumpBox(texture, mag,  h, w, d, resolution);
}

TactileModel.prototype = {
	load: function(engine, fn, tc){
		// load routine for model
		var self = this;
		this[engine].load(function(){
			console.log("Passing back", engine, self.name);	
			fn(tc, self);
		});
	}, 
	mag: function(engine, mag){
		// this[engine].position.x = mag;
		this[engine].raise(mag);
	},
	save: function(name){
		console.log("Saved!");
		this.bump.save(name);
	}
}

function configureGUI(tc){
	$.each(TactileController.textures, function(i, el){
			var path_tokens = el.split('/');
			var name = path_tokens[path_tokens.length - 1].split(".")[0];
			textureMap[name] = el;
	});

	var gui = new dat.GUI();

	var texture = gui.add(tc, 'texture', textureNames);

	texture.onChange(function(){
		tc.switch();
		// model.map(model.filename);
		// img_preview.swap(model.directory + model.filename);
	});

	var engineController = gui.add(tc, 'engine', ["shade", "bump"]);
	engineController.onChange(function(){ tc.switch(); });

	var magnitudeController = gui.add(tc, 'magnitude', 0, 30);
	magnitudeController.onChange(function(){ tc.mag(); });

	var clear_cache = gui.add(tc, 'clear_cache');
	var clear_cache = gui.add(tc, 'clear_self');
	// export
	var exporter = gui.add(tc, 'save');

}

function generateURL(){
	return {
		title: tc.texture + " rendered as " + tc.engine,
		href: "height_displacement?engine=" + tc.engine +"&" + "texture=" + tc.texture
		}
}
</script>

<style type="text/css">
	#texture-render{
		display: none;
	}
</style>
<div class="threejs_container">
<div id="ThreeJS" ></div>
</div>
<canvas id="texture-render" ></canvas>
