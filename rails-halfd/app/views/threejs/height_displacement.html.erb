<%= javascript_include_tag 'metamorphehalf/planebox', 'data-turbolinks-track' => true %>


<%= render :partial => "shader" %>
<style type="text/css">
	html, body{
		height: 100% !important;
	}
</style>
<script type="text/javascript">
var model;
var img_preview;
var storage;

$(function(){
	storage = new WebStorage();

	
	var env = new WebEnv($("#ThreeJS"));
	model = new STLGenerator(env);


	var gui = new dat.GUI();
	var engineController = gui.add(model, 'soft_engine');

	engineController.onChange(function(){
		var start = new Date();  // log start timestamp
		model.update("soft_engine");
		var end =  new Date();  // log end timestamp
		var diff = end - start;
		var engine = model.soft_engine ? "GPU": "CPU";
		// console.log("Engine change on ", engine, ":", diff, "ms");
	});

	var magnitudeController = gui.add(model, 'magnitude', 0, 500);
	magnitudeController.onFinishChange(function(){
		var start = new Date();  // log start timestamp
		model.update("magnitude");
		var end =  new Date();  // log end timestamp
		var diff = end - start;
		var engine = model.soft_engine ? "GPU": "CPU";
		// console.log("Depth mapping update on ", engine, ":", diff, "ms");
	});

	// export
	gui.add(model, 'filename');
	var exporter = gui.add(model, 'export_as');
	

	img = '/heightmap/images/corn.jpg';
	img_preview = addImagePreview(env.container, img);
	model.map(img, 200.0);
});

$(window).resize(function(){
	console.log("Resized!");
	THREEx.WindowResize(model.env.renderer, model.env.camera);
});


function STLGenerator(env){
	this.img, this.shaderMaterial;

	this.env = env;
	this.filename = "corn.stl"
	
	// dat.gui parameterss
	this.soft_engine = true;
	this.magnitude = 200;
	
	//add obj to the env
	this.obj = this.init(1000, 1000, 10); // Setup the plane
	this.obj.geometry.original = clone_vec_array(this.obj.geometry.vertices); //Keep the original geometry


	// begin the render look
	this.update("soft_engine");
	var self = this;
	this.export_as = function(){
		console.log(self.filename);
		self.export(self.filename);
	}
}


STLGenerator.prototype = {
	// Initializes a plane, calculates UV coordinates
	init: function(w, h, resolution){
		var w_segments = parseInt(w / resolution);
		var h_segments = parseInt(h / resolution);

		// STLGenerator.textureMaterial
		// var planeGeo = new THREE.PlaneGeometry( w, h, w_segments, h_segments) ;
		// var plane = new THREE.Mesh(	planeGeo,  STLGenerator.lambertMaterial);
		// plane.rotation.x = -Math.PI / 2;
		// plane.position.y = -100;
		// this.env.scene.add( plane );

		pb = new PlaneBox(1000, 1000, 200, 100, 100, 1, STLGenerator.textureMaterial);
		this.env.scene.add(pb.mesh);
		return pb;
		// return plane;
	
	},
	// Takes in a texture image, uses ImageUtil to load texture and sample via

	// U/V coordinates, scales to the absolute depth. Stores new vertices in a temporary data structure which toggleTexture Engine uses to reduce render time.
	map: function(url, absolute_depth){
		this.image = url;
		this.shaderMaterial =  STLGenerator.makeShaderTexture(url, absolute_depth); // generates a material and passes back uniforms		
		this.update("soft_engine");
	}, 
	update: function (param) {
		if(param == "soft_engine"){
			if(typeof this.shaderMaterial === "undefined") return;
			if(this[param]){
				// UPDATE GPU ENGINE
				this.obj.geometry.vertices = clone_vec_array(this.obj.geometry.original);
				this.obj.geometry.verticesNeedUpdate = true;
				this.obj.mesh.material = this.shaderMaterial;

			} else{
				// UPDATE PHYSICAL/CPU ENGINE
				var self = this;
				if(typeof this.depth_map === "undefined")
					this.depth_map = storage.cache(this.image, function(){ 
						return STLGenerator.cacheDepthMap(self.shaderMaterial, self.obj)
					}, function(val){
						return $.map(val, function(val, i){
							return new THREE.Vector3(val.x, val.y, val.z);
						});
					});
				// if(typeof this.depth_map === "undefined")
				// 	this.depth_map = STLGenerator.cacheDepthMap(this.shaderMaterial, this.obj);

				this.obj.mesh.material = STLGenerator.lambertMaterial;
				this.raise(200/250.0);
				this.obj.geometry.verticesNeedUpdate = true;
			}
		}
		else if(param == "magnitude"){
			if(this.soft_engine){
				// UPDATE THE GPU ENGINE
				this.shaderMaterial.uniforms.bumpScale.value = this.magnitude;
				this.obj.geometry.verticesNeedUpdate = true;
			}
			else{
				// UPDATE THE PHYSICAL/CPU ENGINE
				var self = this;
				if(typeof this.depth_map === "undefined")
					this.depth_map = storage.cache(this.image, function(){ 
						return STLGenerator.cacheDepthMap(self.shaderMaterial, self.obj)
					}, function(val){
						return $.map(val, function(val, i){
							return new THREE.Vector3(val.x, val.y, val.z);
						});
					});

				// if(typeof this.depth_map === "undefined")
				// 	this.depth_map = STLGenerator.cacheDepthMap(this.shaderMaterial, this.obj);
				this.raise(this.magnitude/250.0);
			}
		}
	},
	raise: function( magnitude ){

		if( typeof this.depth_map  === "undefined") return;

		var geometry = this.obj.geometry;
		var vertices = clone_vec_array(this.obj.geometry.original);
		var depth_map = STLGenerator.adjustDepthMap(this.depth_map, magnitude);
	    
	    // for(var vertexID in depth_map) //&& applyToTop
	    // 	vertices[vertexID].add(depth_map[vertexID]);

	    model.obj.applyToTop(function(vertex, id){
	    	vertex.add(depth_map[id]);
	    }, vertices);

    	model.obj.geometry.vertices = vertices;
    	model.obj.geometry.verticesNeedUpdate = true;
	} ,
	export: function(filename){
	    AsciiStlWriter.save(model.obj.geometry, filename);
	} 
}

STLGenerator.adjustDepthMap = function(depthMap, magnitude){
	var new_depth = []
	for(var i in depthMap)
		new_depth[i] = depthMap[i].clone().multiplyScalar(magnitude);
	return new_depth;
}

STLGenerator.cacheDepthMap = function(shaderMaterial, obj){
	
	if( typeof shaderMaterial  === "undefined") return;
	// vertexID ==> normal * grayImagePixel 
	depthMap = [];

		var geometry = obj.geometry;
		var vertices = clone_vec_array(obj.geometry.original);
	    var faces = geometry.faces;
	    var texture = shaderMaterial.uniforms.bumpTexture.value;
	      

	    for (i = 0; i < geometry.faces.length ; i++) {

	      var uv1 = geometry.faceVertexUvs[0][i][0];
	      var v1 = vertices[faces[i].a];

	      
	      var uv2 = geometry.faceVertexUvs[0][i][1];
	      var v2 = vertices[faces[i].b];	
	      
	      var uv3 = geometry.faceVertexUvs[0][i][2];
	      var v3 = vertices[faces[i].c];

	      var normal = faces[i].normal;
	    
	      depthMap[faces[i].a] = normal.clone().multiplyScalar(texture.getUV(uv1));
	      depthMap[faces[i].b] = normal.clone().multiplyScalar(texture.getUV(uv2));
	      depthMap[faces[i].c] = normal.clone().multiplyScalar(texture.getUV(uv3));
 
    	}
   
    	return depthMap; 
}

STLGenerator.makeShaderTexture = function(url, magnitude){
	var bumpTexture = new THREE.ImageUtils.loadTexture(url);
	bumpTexture.wrapS = bumpTexture.wrapT = THREE.RepeatWrapping; 
	var bumpScale   = magnitude;		
	var customUniforms = {
		bumpTexture:	{ type: "t", value: bumpTexture },
		bumpScale:	    { type: "f", value: bumpScale },
	};

	var phongShader = THREE.ShaderLib.phong;
	var uniforms = THREE.UniformsUtils.clone(phongShader.uniforms);
	uniforms.bumpTexture = { type: "t", value: bumpTexture };
	uniforms.bumpScale = { type: "f", value: bumpScale };
	
	return new THREE.ShaderMaterial({
		    uniforms: uniforms,
			vertexShader:  phongShader.vertexShader, //document.getElementById( 'vertexShader' ).textContent,
			fragmentShader: phongShader.fragmentShader, //document.getElementById( 'fragmentShader' ).textContent,
		  	lights:true,
    		fog: true,
			side: THREE.DoubleSide
		});
}




STLGenerator.textureMaterial = STLGenerator.makeShaderTexture('/heightmap/images/heightmap.png', 200.0).material;
STLGenerator.lambertMaterial = new THREE.MeshPhongMaterial({
						        // light
						        // specular: '#a9fcff',
						        // intermediate
						        // color: '#00abb1',
						        ambient: new THREE.Color( 0xffffff ),
						        // dark
						        specular: new THREE.Color( 0x111111 ),
						        emissive: new THREE.Color( 0x000000 ),
						        side: THREE.DoubleSide,
						        shininess: 30
						      });

							// new THREE.MeshBasicMaterial({
						 //      color: 0x333333, 
						 //      side: THREE.DoubleSide
						 //    });
function addImagePreview(container, url){
	var img = new Image();
	img.src = url;
	$(img).css({
		position: "relative", 
		width: 100,
		border: "1px solid #00A8E1", 
		top: - $(container).height() + 72, 
		left: 0, 
		"margin-top": -100,
		"z-index": 100
	}).appendTo(container);
	return img;
}


function addStats(container){
	// STATS
	var stats = new Stats();
	stats.domElement.style.position = 'relative';
	stats.domElement.style.top = '-55px';
	stats.domElement.style.left = '0px';
	stats.domElement.style.zIndex = 100;
	$(stats.domElement).css("position", "absolute");
	container.appendChild( stats.domElement );
	return stats;
}
</script>

<style type="text/css">
	#texture-render{
		display: none;
	}
</style>
<div class="threejs_container">
<div id="ThreeJS" ></div>
</div>
<canvas id="texture-render" ></canvas>
