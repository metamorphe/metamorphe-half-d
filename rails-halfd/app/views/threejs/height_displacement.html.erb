

<%= render :partial => "shader" %>
<style type="text/css">
	html, body{
		height: 100% !important;
	}
</style>
<script type="text/javascript">
var model;
var img_preview;


$(function(){
	var env = new WebEnv($("#ThreeJS"));
	model = new STLGenerator(env);

	var gui = new dat.GUI();
	var engineController = gui.add(model, 'soft_engine');

	engineController.onChange(function(){
		model.update("soft_engine");
	});

	var magnitudeController = gui.add(model, 'magnitude', 0, 500);
	magnitudeController.onFinishChange(function(){
		model.update("magnitude");
	});

	img = '/heightmap/images/corn.jpg';
	img_preview = addImagePreview(env.container, img);
	model.map(img, 200.0);
});

$(window).resize(function(){
	console.log("Resized!");
	THREEx.WindowResize(model.env.renderer, model.env.camera);
});


function STLGenerator(env){
	this.img, this.shaderMaterial;

	this.env = env;
	
	// dat.gui parameterss
	this.soft_engine = true;
	this.magnitude = 200;
	
	//add obj to the env
	this.obj = this.init(1000, 1000, 10); // Setup the plane
	this.obj.geometry.original = clone_vec_array(this.obj.geometry.vertices); //Keep the original geometry

	// begin the render look
	this.update("soft_engine");
}


STLGenerator.prototype = {
	// Initializes a plane, calculates UV coordinates
	init: function(w, h, resolution){
		var w_segments = parseInt(w / resolution);
		var h_segments = parseInt(h / resolution);

		// STLGenerator.textureMaterial
		var planeGeo = new THREE.PlaneGeometry( w, h, w_segments, h_segments) ;
		var plane = new THREE.Mesh(	planeGeo,  STLGenerator.lambertMaterial);
		plane.rotation.x = -Math.PI / 2;
		plane.position.y = -100;
		this.env.scene.add( plane );
		return plane;
	},
	// Takes in a texture image, uses ImageUtil to load texture and sample via

	// U/V coordinates, scales to the absolute depth. Stores new vertices in a temporary data structure which toggleTexture Engine uses to reduce render time.
	map: function(url, absolute_depth){
		this.image = url;
		this.shaderMaterial =  STLGenerator.makeShaderTexture(url, absolute_depth); // generates a material and passes back uniforms		
		this.update("soft_engine");
	}, 
	update: function (param) {
		if(param == "soft_engine"){
			if(typeof this.shaderMaterial === "undefined") return;
			if(this[param]){
				// UPDATE GPU ENGINE
				this.obj.geometry.vertices = clone_vec_array(this.obj.geometry.original);
				this.obj.geometry.verticesNeedUpdate = true;
				this.obj.material = this.shaderMaterial;

			} else{
				// UPDATE PHYSICAL/CPU ENGINE
				this.obj.material = STLGenerator.lambertMaterial;
				this.raise(0.1);
				this.obj.geometry.verticesNeedUpdate = true;
			}
		}
		else if(param == "magnitude"){
			if(this.soft_engine){
				// UPDATE THE GPU ENGINE
				this.shaderMaterial.uniforms.bumpScale.value = this.magnitude;
				this.obj.geometry.verticesNeedUpdate = true;
			}
			else{
				// UPDATE THE PHYSICAL/CPU ENGINE
				this.raise(this.magnitude);
			}
		}
	},
	raise: function( magnitude ){
		if( typeof this.shaderMaterial  === "undefined") return;
		var geometry = this.obj.geometry;
		var vertices = clone_vec_array(this.obj.geometry.original);
	    var faces = geometry.faces;

	    for (i = 0; i < geometry.faces.length ; i++) {

	      var uv1 = geometry.faceVertexUvs[0][i][0];
	      var v1 = vertices[faces[i].a];
	      
	      var uv2 = geometry.faceVertexUvs[0][i][1];
	      var v2 = vertices[faces[i].b];	
	      
	      var uv3 = geometry.faceVertexUvs[0][i][2];
	      var v3 = vertices[faces[i].c];

	      var normal = faces[i].normal;
	      // console.log(faces[i].normal);
	      // console.log(v)
	      var texture = this.shaderMaterial.uniforms.bumpTexture.value;
	      v1.add(normal.clone().multiplyScalar(texture.getUV(uv1) * magnitude));
	      v2.add(normal.clone().multiplyScalar(texture.getUV(uv2) * magnitude));
	      v3.add(normal.clone().multiplyScalar(texture.getUV(uv3) * magnitude));
 
    	}
    	model.obj.geometry.vertices = vertices;
    	model.obj.geometry.verticesNeedUpdate = true;
	} ,
	generateSTL: function(){

	}, 
}


STLGenerator.makeShaderTexture = function(url, magnitude){
	var bumpTexture = new THREE.ImageUtils.loadTexture(url);
	bumpTexture.wrapS = bumpTexture.wrapT = THREE.RepeatWrapping; 
	var bumpScale   = magnitude;		
	var customUniforms = {
		bumpTexture:	{ type: "t", value: bumpTexture },
		bumpScale:	    { type: "f", value: bumpScale },
	};

	var phongShader = THREE.ShaderLib.phong;
	var uniforms = THREE.UniformsUtils.clone(phongShader.uniforms);
	uniforms.bumpTexture = { type: "t", value: bumpTexture };
	uniforms.bumpScale = { type: "f", value: bumpScale };
	
	return new THREE.ShaderMaterial({
		    uniforms: uniforms,
			vertexShader:  phongShader.vertexShader, //document.getElementById( 'vertexShader' ).textContent,
			fragmentShader: phongShader.fragmentShader, //document.getElementById( 'fragmentShader' ).textContent,
		  	lights:true,
    		fog: true,
			side: THREE.DoubleSide
		});
}




STLGenerator.textureMaterial = STLGenerator.makeShaderTexture('/heightmap/images/heightmap.png', 200.0).material;
STLGenerator.lambertMaterial = new THREE.MeshPhongMaterial({
						        // light
						        // specular: '#a9fcff',
						        // intermediate
						        // color: '#00abb1',
						        ambient: new THREE.Color( 0xffffff ),
						        // dark
						        specular: new THREE.Color( 0x111111 ),
						        emissive: new THREE.Color( 0x000000 ),
						        side: THREE.DoubleSide,
						        shininess: 30
						      });

							// new THREE.MeshBasicMaterial({
						 //      color: 0x333333, 
						 //      side: THREE.DoubleSide
						 //    });
function addImagePreview(container, url){
	var img = new Image();
	img.src = url;
	$(img).css({
		position: "relative", 
		width: 100,
		border: "1px solid #00A8E1", 
		top: - $(container).height() + 72, 
		left: 0, 
		"margin-top": -100,
		"z-index": 100
	}).appendTo(container);
	return img;
}


function addStats(container){
	// STATS
	var stats = new Stats();
	stats.domElement.style.position = 'relative';
	stats.domElement.style.top = '-55px';
	stats.domElement.style.left = '0px';
	stats.domElement.style.zIndex = 100;
	container.appendChild( stats.domElement );
	return stats;
}
</script>

<style type="text/css">
	#texture-render{
		display: none;
	}
</style>
<div id="ThreeJS" ></div>
<canvas id="texture-render" ></canvas>
