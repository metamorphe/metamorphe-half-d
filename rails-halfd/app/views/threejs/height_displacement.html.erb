<!DOCTYPE html>
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

<script type="text/javascript">
$(function(){
	var env = new WebEnv($("#ThreeJS"));
	var model = new STLGenerator(env);
});


function STLGenerator(env){
	this.engine = STLGenerator.SoftTexture; 
	this.env = env;
	this.init();
}

STLGenerator.HardTexture = 1; 
STLGenerator.SoftTexture = 0; 

STLGenerator.prototype = {
	// Initializes a plane, calculates UV coordinates
	init: function(){
		// obj.geometry.soft_vertices = clone_vec_array();


		// texture used to generate "bumpiness"
		var bumpTexture = new THREE.ImageUtils.loadTexture( '/heightmap/images/heightmap.png' );
		bumpTexture.wrapS = bumpTexture.wrapT = THREE.RepeatWrapping; 
		// magnitude of normal displacement
		var bumpScale   = 200.0;
		
		customUniforms = {
			bumpTexture:	{ type: "t", value: bumpTexture },
			bumpScale:	    { type: "f", value: bumpScale },
		};
		
		// create custom material from the shader code above
		//   that is within specially labelled script tags
		var customMaterial = new THREE.ShaderMaterial( 
		{
		    uniforms: customUniforms,
			vertexShader:   document.getElementById( 'vertexShader'   ).textContent,
			fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
			side: THREE.DoubleSide
		}   );

		// create custom material from the shader code above
		//   that is within specially labelled script tags
		var customMaterial = new THREE.ShaderMaterial( 
		{
		    uniforms: customUniforms,
			vertexShader:   document.getElementById( 'vertexShader'   ).textContent,
			fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
			side: THREE.DoubleSide
		}   );
			
		// var lambert_mat =
		//   new THREE.MeshPhongMaterial(
		//     {
		//       color: 0xDDDDDD
		//     });
					
		var planeGeo = new THREE.PlaneGeometry( 1000, 1000, 100, 100 );
		var plane = new THREE.Mesh(	planeGeo, customMaterial );
		plane.rotation.x = -Math.PI / 2;
		plane.position.y = -100;
		this.env.scene.add( plane );

	},
	// Takes in a texture image, uses ImageUtil to load texture and sample via
	// U/V coordinates, scales to the absolute depth. Stores new vertices in a temporary data structure which toggleTexture Engine uses to reduce render time.
	map: function(texture, absolute_depth){

	}, 
	toggleTextureEngine: function(engine){
		if(engine == STLGenerator.HardTexture){
			this.obj.geometry = this.obj.hard_vertices;
		} else if (engine == STLGenerator.SoftTexture){
			this.obj.geometry = this.obj.soft_vertices;
		}
		this.engine = engine; 
	},
	assignUVs: function( obj ){
		var geometry = obj.geometry;
	    geometry.computeBoundingBox();

	    var max     = geometry.boundingBox.max;
	    var min     = geometry.boundingBox.min;

	    var offset  = new THREE.Vector2(0 - min.x, 0 - min.y);
	    var range   = new THREE.Vector2(max.x - min.x, max.y - min.y);

	    geometry.faceVertexUvs[0] = [];
	    var faces = geometry.faces;

	    for (i = 0; i < geometry.faces.length ; i++) {

	      var v1 = geometry.vertices[faces[i].a];
	      var v2 = geometry.vertices[faces[i].b];
	      var v3 = geometry.vertices[faces[i].c];

	      geometry.faceVertexUvs[0].push([
	        new THREE.Vector2( ( v1.x + offset.x ) / range.x , ( v1.y + offset.y ) / range.y ),
	        new THREE.Vector2( ( v2.x + offset.x ) / range.x , ( v2.y + offset.y ) / range.y ),
	        new THREE.Vector2( ( v3.x + offset.x ) / range.x , ( v3.y + offset.y ) / range.y )
	      ]);

	    }

	    geometry.uvsNeedUpdate = true;

	}, 
	generateSTL: function(){
		toggleTextureEngine(STLGenerator.HardTexture);
	}
}

function clone_vec_array (arr) {
	var clone = [];
	for(var i in arr){
		clone.push(arr[i].clone());
	}
	return 
}
</script>




<!-- ---------------- Custom Shader Code ------------------------ -->
<script id="vertexShader" type="x-shader/x-vertex">
uniform sampler2D bumpTexture;
uniform float bumpScale;

varying float vAmount;
varying vec2 vUV;

void main() 
{ 
	vUV = uv;
	vec4 bumpData = texture2D( bumpTexture, uv );
	
	vAmount = bumpData.r; // assuming map is grayscale it doesn't matter if you use r, g, or b.
	
	// move the position along the normal
    vec3 newPosition = position + normal * bumpScale * vAmount;
	
	gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
}
</script>

<!-- fragment shader a.k.a. pixel shader -->
<script id="fragmentShader" type="x-shader/x-vertex"> 
void main() 
{
	gl_FragColor = vec4(0.2, 0.2, 0.2, 1.0);
}  
</script>

<div id="ThreeJS" ></div>

<script>

$(function(){
	// PREVENT BROWSER BUMP
	$(window).on('scroll', function(e){
	   scrollAmount = $(this).scrollTop();
	   if(scrollAmount < 1){
	      $(this).scrollTop(1);
	   }
	   if(scrollAmount > $(document).height() - $(window).height()){
	      $(this).scrollTop($(window).height());
	   }
	});
})


function addStats(container){
	// STATS
	var stats = new Stats();
	stats.domElement.style.position = 'relative';
	stats.domElement.style.top = '-55px';
	stats.domElement.style.left = '0px';
	stats.domElement.style.zIndex = 100;
	container.appendChild( stats.domElement );
	return stats;
}

</script>

